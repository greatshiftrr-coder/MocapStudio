<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Android Mocap Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: #000; color: #fff; overflow: hidden; touch-action: none; }
        .mobile-btn { -webkit-tap-highlight-color: transparent; }
        #webcam { transform: scaleX(-1); visibility: hidden; position: absolute; }
        canvas { display: block; }
    </style>
</head>
<body class="bg-slate-950 font-sans">

    <!-- Mobile Start Overlay -->
    <div id="overlay" class="fixed inset-0 z-[100] flex flex-col items-center justify-center bg-slate-900 p-8 text-center">
        <div class="mb-6 w-20 h-20 bg-blue-500/20 rounded-full flex items-center justify-center border border-blue-500/50">
            <svg class="w-10 h-10 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
        <h1 class="text-3xl font-bold mb-2">TABLET MOCAP</h1>
        <p id="status" class="text-slate-400 text-sm mb-8">Please allow camera access when prompted.</p>
        <button id="start-btn" class="mobile-btn w-full max-w-xs py-5 bg-blue-600 hover:bg-blue-500 rounded-2xl font-black text-xl shadow-2xl active:scale-95 transition-all">
            ACTIVATE CAMERA
        </button>
        <p class="mt-6 text-[10px] text-slate-500 uppercase tracking-widest">Optimized for Android</p>
    </div>

    <!-- Main App -->
    <div class="fixed inset-0 flex flex-col">
        <!-- 3D View -->
        <div id="viewport" class="relative flex-grow bg-black">
            <div id="rec-status" class="hidden absolute top-4 left-4 bg-red-600 px-3 py-1 rounded-full text-[10px] font-bold animate-pulse">RECORDING</div>
            <div class="absolute bottom-4 left-4 text-[10px] text-blue-400/50 font-mono" id="fps-display">FPS: 0</div>
        </div>

        <!-- Mobile Controls -->
        <div class="h-40 bg-slate-900 border-t border-white/10 flex items-center px-6 gap-4">
            <div class="flex-grow space-y-2">
                <button id="rec-btn" class="mobile-btn w-full py-4 bg-blue-600 rounded-xl font-bold text-sm uppercase">Start Recording</button>
                <button id="dl-btn" class="hidden mobile-btn w-full py-3 bg-white text-black rounded-xl font-bold text-[10px] uppercase">Download JSON</button>
            </div>
            <video id="webcam" playsinline muted></video>
            <!-- Preview Box -->
            <div class="w-32 aspect-video bg-black rounded-lg overflow-hidden border border-white/10">
                <canvas id="mini-preview" class="w-full h-full object-cover opacity-50"></canvas>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, body = {}, hands = {L:[], R:[]};
        let holistic, isRecording = false, recordingData = [];
        let frames = 0, lastTime = 0;

        async function start() {
            const status = document.getElementById('status');
            const btn = document.getElementById('start-btn');
            btn.disabled = true;
            status.innerText = "Requesting Hardware...";

            try {
                // Mobile specific constraints
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: "user",
                        width: { ideal: 320 },
                        height: { ideal: 240 }
                    } 
                });
                
                const video = document.getElementById('webcam');
                video.srcObject = stream;
                await video.play();

                status.innerText = "Initializing AI Engine...";
                setup3D();

                holistic = new Holistic({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
                });

                holistic.setOptions({
                    modelComplexity: 0,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                holistic.onResults(onResults);

                // Manual loop for better mobile stability
                async function process() {
                    await holistic.send({image: video});
                    // Draw mini preview
                    const mini = document.getElementById('mini-preview');
                    const ctx = mini.getContext('2d');
                    mini.width = video.videoWidth;
                    mini.height = video.videoHeight;
                    ctx.drawImage(video, 0, 0);
                    requestAnimationFrame(process);
                }
                
                process();
                document.getElementById('overlay').style.display = 'none';
                animate();

            } catch (err) {
                status.innerText = "Error: " + err.message;
                status.classList.add('text-red-500');
                btn.disabled = false;
                btn.innerText = "TRY AGAIN";
            }
        }

        function setup3D() {
            const container = document.getElementById('viewport');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, container.clientWidth/container.clientHeight, 0.1, 100);
            camera.position.set(0, 1.2, 3);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            scene.add(new THREE.GridHelper(10, 10, 0x333333, 0x111111));
            
            const bMat = new THREE.MeshBasicMaterial({ color: 0x3b82f6 });
            const hMat = new THREE.MeshBasicMaterial({ color: 0x10b981 });
            const geo = new THREE.SphereGeometry(0.05, 8, 8);
            const fGeo = new THREE.SphereGeometry(0.02, 6, 6);

            [11,12,13,14,15,16,23,24,25,26,27,28].forEach(id => {
                const m = new THREE.Mesh(geo, bMat);
                scene.add(m);
                body[id] = m;
            });

            for(let i=0; i<21; i++) {
                const l = new THREE.Mesh(fGeo, hMat);
                const r = new THREE.Mesh(fGeo, hMat);
                scene.add(l); scene.add(r);
                hands.L.push(l); hands.R.push(r);
            }
        }

        function onResults(res) {
            frames++;
            const now = performance.now();
            if(now - lastTime > 1000) {
                document.getElementById('fps-display').innerText = "FPS: " + frames;
                frames = 0; lastTime = now;
            }

            if(res.poseLandmarks) {
                Object.keys(body).forEach(id => {
                    const lm = res.poseLandmarks[id];
                    body[id].position.set((0.5 - lm.x)*3, (0.5 - lm.y)*3 + 1, -lm.z*2);
                });
            }

            const map = (lms, msh) => {
                if(lms) {
                    lms.forEach((lm, i) => {
                        msh[i].visible = true;
                        msh[i].position.set((0.5 - lm.x)*3, (0.5 - lm.y)*3 + 1, -lm.z*2);
                    });
                } else {
                    msh.forEach(m => m.visible = false);
                }
            };
            map(res.leftHandLandmarks, hands.L);
            map(res.rightHandLandmarks, hands.R);

            if(isRecording) {
                recordingData.push({ t: Date.now(), p: res.poseLandmarks, lh: res.leftHandLandmarks, rh: res.rightHandLandmarks });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        document.getElementById('start-btn').onclick = start;

        document.getElementById('rec-btn').onclick = function() {
            isRecording = !isRecording;
            const rs = document.getElementById('rec-status');
            const dl = document.getElementById('dl-btn');
            if(isRecording) {
                recordingData = [];
                this.innerText = "Stop Capture";
                this.classList.replace('bg-blue-600', 'bg-red-600');
                rs.classList.remove('hidden');
                dl.classList.add('hidden');
            } else {
                this.innerText = "Start Recording";
                this.classList.replace('bg-red-600', 'bg-blue-600');
                rs.classList.add('hidden');
                if(recordingData.length > 0) dl.classList.remove('hidden');
            }
        };

        document.getElementById('dl-btn').onclick = () => {
            const blob = new Blob([JSON.stringify(recordingData)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tablet_mocap_${Date.now()}.json`;
            a.click();
        };

        window.onresize = () => {
            const container = document.getElementById('viewport');
            camera.aspect = container.clientWidth/container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        };
    </script>
</body>
</html>

